#include <iostream>
using namespace std;

// Описание:
//      Намира дължината на даден символен низ (рекурсивно).
// Входни параметри на функцията:
//     -const char *text - указател към символeн низ
// Връщан резултат:
//     -size_t - дължината на символен низ
size_t strlen(const char* str){
  // Базовият случай (дъно на рекурсията) е случая
  // ,в който подаденият стринг е NULL (!str) или пък
  // е празният стринг (!*str), в такъв случай връщаме 0:
  if (!str || !*str) return 0;
  // Иначе извикваме функцията рекурсивно, като знаем, че
  // при такова положение имаме поне един символ.
  // Това може да се чете по следния начин:
  // "Ако низът е ненулев, то неговата дължина е 1 (текущия символ) + дължината на останалата част от низа":
  return 1 + strlen(++str);
}

bool is_letter(char c){
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Описание:
//      Намира най-голямата буква (тази с най-голям ASCII код) в низа.
// Входни параметри на функцията:
//     -const char *text - указател към символeн низ
//     -char max=0       - параметър по подразбиране,
//                         който при връщане от функцията, ще съдържа най-голямата буква
// Връщан резултат:
//     -char - най-голямата буква в низа
char max_char(const char *text, char max=0){
  if (!text || !*text) return max;
  // Ако текущия символ е буква и ASCII кода му е > max,
  // то новият max e текущия символ:
  if(is_letter(*text) && *text > max) max = *text;
  // Иначе търсим най-голямата буква в останалата част от низа и
  // най-голямата намерената до момента:
  return max_char(++text, max);
}

// Описание:
//      Намира броят думи в даден низ, разделени с разделител delimeter.
// Входни параметри на функцията:
//     -const char *text      - указател към символeн низ
//     -const char &delimeter - разделител по подразбиране
// Връщан резултат:
//     -size_t - броят думи в низа
size_t words_count(const char *text, const char &delimeter=' '){
  if (!text || !*text) return 1;
  // Ако текущия символ в момента е разделител, то сме достигнали
  // дума и я преброяваме. Викаме функцията рекурсивно за да преброим
  // останалите думи в низа. Кога няма да работи? :)
  if (*text == delimeter) return 1 + words_count(++text);
  // Ако текущия символ не е разеделител, то той е буква.
  // Тогава викаме рекурсивно функцията, без да броим дума:
  return words_count(++text);
}

int main(){
  const char *text = "random text here";
  cout << "Length of " << text << ": " << strlen(text) << "\n";
  cout << "Max char: " << max_char(text) << "\n";
  cout << "Words count: " << words_count(text) << "\n";
  return 0;
}
